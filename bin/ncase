#!/usr/bin/env ruby
# frozen_string_literal: true

$LOAD_PATH.unshift("#{__dir__}/../lib")

require "ncase"
require "optparse"

case_to = "random"
OptionParser.new do |opts|
  opts.banner = "Usage: ncase [OPTIONS] [TEXT]"
  opts.version = Ncase::VERSION

  opts.on("-c", "--camel-case",       "Enforce camelCase")     { case_to = "camel" }
  opts.on("-P", "--pascal-case",      "Enforce PascalCase")    { case_to = "pascal" }
  opts.on("-k", "--kebab-case",       "Enforce kebab-case")    { case_to = "kebab" }
  opts.on("-K", "--upper-kebab-case", "Enforce KEBAB-CASE")    { case_to = "upper_kebab" }
  opts.on("-l", "--lower-case",       "Enforce `lower case`")  { case_to = "lower" }
  opts.on("-U", "--upper-case",       "Enforce `UPPER CASE`")  { case_to = "upper" }
  opts.on("-s", "--snake-case",       "Enforce snake_case")    { case_to = "snake" }
  opts.on("-S", "--upper-snake-case", "Enforce SNAKE_CASE")    { case_to = "upper_snake" }
  opts.on("-t", "--title-case",       "Enforce `Title Case`")  { case_to = "title" }
  opts.on("-T", "--inver-title-case", "Enforce `tITLE cASE`")  { case_to = "inver_title" }
  opts.on("-r", "--random-case",      "Enforce `rAnDOm CaSe`") { case_to = "random" }
end.parse!

in_lines = if ARGV.empty? then readlines else [ARGV.join(" ")] end
out_lines = in_lines.map {|l| Ncase::Words.new(l).send (case_to + "_case").to_sym}
puts out_lines
